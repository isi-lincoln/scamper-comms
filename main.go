package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"strconv"
	"strings"
	"time"

	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
)

var (
	server    string
	port      int
	format    string
	isWarts   bool
	waitDelay     = 5 * time.Second
	buffer    int = 4096
	threshold int
	api       string
)

/* Generated by LLM */

type Country struct {
	Name   string `json:"name"`
	ISO    string `json:"iso"`
	Threat int    `json:"threat"`
}

type ASN struct {
	ASN     int     `json:"asn"`
	Name    string  `json:"name"`
	Country Country `json:"country"`
	Threat  int     `json:"threat"`
}

type Organization struct {
	Name   string `json:"name"`
	Method string `json:"method"`
}

type Reserved struct {
	Name    string `json:"name"`
	Network string `json:"network"`
}

type Hop struct {
	IP           string       `json:"ip"`
	ProbeTTL     int          `json:"probe_ttl"`
	ASN          ASN          `json:"asn"`
	Country      Country      `json:"country,omitempty"`
	Organization Organization `json:"organization"`
	Reserved     Reserved     `json:"reserved,omitempty"`
	Threat       int          `json:"threat"`
}

type Data struct {
	ID           int       `json:"id"`
	Src          string    `json:"src"`
	Dst          string    `json:"dst"`
	Hops         []Hop     `json:"hops"`
	Finished     bool      `json:"finished"`
	TimeCreated  time.Time `json:"time_created"`
	TimeModified time.Time `json:"time_modified"`
	Errors       []string  `json:"errors"`
}

type Response struct {
	TotalCount int      `json:"totalCount"`
	PageSize   int      `json:"pageSize"`
	Page       int      `json:"page"`
	Data       []Data   `json:"data"`
	Errors     []string `json:"errors"`
}

/* Fin */

func main() {

	var root = &cobra.Command{
		Use:   "connect",
		Short: "managing scamper and scamper output to pathfinder",
	}

	root.Flags().StringVarP(&server, "server", "s", "localhost", "server scamper is running on")
	root.Flags().IntVarP(&port, "port", "p", 31337, "scamper daemon port")
	root.Flags().StringVarP(&format, "format", "f", "json", "format scamper output (json, warts)")

	var scamper = &cobra.Command{
		Use:   "scamper \"<cmd>\"",
		Short: "connect to a scamper socket",
		Long:  "scamper -s localhost -p 31337 \"trace -q 1 -w 1 8.8.8.8\"",
		Args:  cobra.ExactArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			// Create the address string
			addr := fmt.Sprintf("%s:%d", server, port)

			if strings.Contains(format, "wart") {
				isWarts = true
			} else {
				isWarts = false
			}
			err := scamperHandler(addr, args[0])
			if err != nil {
				log.Fatal(err)
			}
		},
	}
	root.AddCommand(scamper)

	var pathfinder = &cobra.Command{
		Use:   "pathfinder <file>",
		Short: "pathfinder -a <api key> -t 3 <file>",
		Long:  "send scamper output json file to pathfinder api service",
		Args:  cobra.ExactArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			defaultEndpoint := "https://api.pathfinder.caida.org/v1/traceroutes"

			if api == "" {
				log.Fatalf("pathfinder requires -a for api key\n")
			}

			migrate, err := pathfinderHandler(defaultEndpoint, args[0])
			if err != nil {
				log.Fatal(err)
			}
			if migrate {
				log.Infof("Threat threhold met: migrating")
			} else {
				log.Infof("Path is safe")
			}
		},
	}
	pathfinder.Flags().IntVarP(&threshold, "threshold", "t", 5, "threshold of the threat level")
	pathfinder.Flags().StringVarP(&api, "api", "a", "", "api key")
	root.AddCommand(pathfinder)

	err := root.Execute()
	if err != nil {
		log.Fatal(err)
	}
}

type PFObj struct {
	Data   []int
	Errors []string
}

func pathfinderHandler(endpoint, inFile string) (bool, error) {

	requestData, err := ioutil.ReadFile(inFile)
	if err != nil {
		return false, err
	}

	// for no reason, there is a newline

	// add crap
	jsonData := "[{\"data\":" + string(requestData[1:]) + "}]"

	log.Infof("our data:\n%s", jsonData)

	req, err := http.NewRequest("POST", endpoint, bytes.NewBuffer([]byte(jsonData)))
	if err != nil {
		return false, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("pathfinder-key", api)

	// Send our request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return false, err
	}
	defer resp.Body.Close()

	log.Infof("Response code: %d\n", resp.StatusCode)

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return false, fmt.Errorf("Http POST failed with status code: %d", resp.StatusCode)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err
	}

	// response: {"data":[118140],"errors":[]}
	responseData := &PFObj{}
	err = json.Unmarshal(body, &responseData)
	if err != nil {
		return false, err
	}

	log.Infof("the response: %v", responseData)

	// TODO: just manage it
	d := responseData.Data
	code := 0
	for _, c := range d {
		code = int(c)
	}
	if len(responseData.Errors) > 0 {
		return false, fmt.Errorf("pathfinder returned error: %v", responseData.Errors)
	}

	// now we do a lookup on the code
	endpoint2 := fmt.Sprintf("%s/%d?hops", endpoint, code)
	req2, err := http.NewRequest("GET", endpoint2, nil)
	if err != nil {
		return false, err
	}

	req2.Header.Set("Content-Type", "application/json")
	req2.Header.Set("pathfinder-key", api)

	// Send our request
	client = &http.Client{}
	resp2, err := client.Do(req2)
	if err != nil {
		return false, err
	}
	defer resp2.Body.Close()

	log.Infof("Response code: %d\n", resp2.StatusCode)

	if resp2.StatusCode != http.StatusOK && resp2.StatusCode != http.StatusCreated {
		return false, fmt.Errorf("Http POST failed with status code: %d", resp2.StatusCode)
	}

	body2, err := ioutil.ReadAll(resp2.Body)
	if err != nil {
		return false, err
	}

	var responseData2 Response
	err = json.Unmarshal(body2, &responseData2)
	if err != nil {
		return false, err
	}

	x := responseData2.Data
	for _, d := range x {
		for _, hop := range d.Hops {
			log.Infof("Hop: %s, Threat: %d", hop.IP, hop.Threat)
			if hop.Threat > threshold {
				return true, nil
			}
		}
	}

	return false, nil
}

func checkOnline(conn net.Conn) (bool, error) {
	log.Infof("In checkOnline 0")

	msg := []byte("help\n")
	_, err := conn.Write(msg)
	if err != nil {
		return false, err
	}

	// should only recieve a one line response
	recv, err := bufio.NewReader(conn).ReadString('\n')

	helpResponse := "ERR XXX: todo\n"
	resp := string(recv)

	log.Infof("help: %s", resp)

	if resp == helpResponse {
		return true, nil
	} else {
		log.Infof("should have got: %s, instead got: %s\n", helpResponse, resp)
		return false, nil
	}

	return false, nil
}

// sudo apt-get install sharutils
func decodeUU(uuencoded []byte) ([]byte, error) {
	preamble := []byte("begin 644 cat.txt")
	ending := append(
		append(
			[]byte{uuencoded[0]},
			[]byte("end")...,
		),
		uuencoded[0],
	)
	var x []byte
	x = append(preamble, uuencoded...)
	x = append(x, ending...)
	log.Infof("x: %s\n", string(x))
	/*
		data, err := uu.Decode(x)
		if err != nil {
			return nil, err
		}
		return data.Data, nil
	*/
	return x, nil
}

func parser(conn net.Conn, resp []byte) ([]int, []byte, error) {

	log.Infof("in parser\n")

	c := make([]int, 0)
	d := make([]byte, 0)
	asLines := strings.Split(string(resp), "\n")

	expectOK := "OK"     // recvieved
	expectMore := "MORE" // there are additional responses
	expectData := "DATA" // DATA [bytes] [id]

	dCounter := 0
	for l, line := range asLines {
		log.Infof("%d: %s\n", l, line)
		if strings.Contains(line, expectOK) {
			sp := strings.Split(line, " ")
			if len(sp) > 1 {
				_ = sp[1] // id
			}
		}
		if strings.Contains(line, expectMore) {
			// for warts we get 2 lines, json only one
			if isWarts {
				dCounter = dCounter + 1
			}
		}
		if strings.Contains(line, expectData) {
			dCounter = dCounter - 1
			format := strings.Split(line, " ")
			_ = format[0]     // DATA
			strb := format[1] // bytes
			b, err := strconv.Atoi(strb)
			if err != nil {
				return nil, nil, fmt.Errorf("expected DATA INT, got: %s", strb)
			}
			if len(format) > 2 {
				_ = format[2] // id
			}

			if l >= len(asLines) {
				return nil, nil, fmt.Errorf("expected DATA, but nothing after data line: %s", line)
			}

			// set x to current loc
			x := len([]byte(strings.Join(asLines[:l+1], "\n")))

			log.Infof("Got: %s\n", resp[x:x+b])

			c = append(c, b)
			var v []byte
			if isWarts {
				v, err = decodeUU(resp[x : x+b])
				if err != nil {
					return nil, nil, err
				}
			} else {
				v = resp[x : x+b]
			}
			d = append(d, v...)
		}
	}

	log.Infof("dCounter: %d\n", dCounter)

	// assumes only 1 MORE
	if dCounter >= 0 {

		log.Infof("Calling parser again")

		// only call this if we didnt read 2 data
		conn.SetReadDeadline(time.Now().Add(waitDelay))

		// read another message
		recv := make([]byte, buffer)
		m, err := conn.Read(recv)
		if err != nil {
			return nil, nil, err
		}

		t, x, err := parser(conn, recv[:m])
		if err != nil {
			return nil, nil, err
		}
		c = append(c, t...)
		d = append(d, x...)

	}

	return c, d, nil
}

func sendFormattingRequest(conn net.Conn) (bool, error) {
	// Send the message "hello"
	msg := []byte(fmt.Sprintf("attach format %s\n", format))
	log.Infof("format: %s", msg)
	_, err := conn.Write(msg)
	if err != nil {
		return false, err
	}
	conn.SetReadDeadline(time.Now().Add(waitDelay))

	// Receive the response
	recv := make([]byte, buffer)
	n, err := conn.Read(recv)
	if err != nil {
		return false, err
	}

	log.Infof("recv'd: %s", string(recv[:n]))

	_, _, err = parser(conn, recv[:n])
	if err != nil {
		return false, err
	}

	return true, nil
}

func sendTrace(conn net.Conn, command string) (bool, []byte, error) {
	// Send the message "hello"
	msg := []byte(fmt.Sprintf("%s\n", command))

	log.Infof("Sending command: %s", msg)

	_, err := conn.Write(msg)
	if err != nil {
		return false, nil, err
	}
	conn.SetReadDeadline(time.Now().Add(waitDelay))

	// Receive the response
	recv := make([]byte, buffer)
	n, err := conn.Read(recv)
	if err != nil {
		return false, nil, err
	}

	x, data, err := parser(conn, recv[:n])
	if err != nil {
		return false, nil, err
	}
	// simplify just return the first
	if len(x) > 1 {
		return true, data[:x[0]], nil
	}

	return true, data, nil
}

func scamperHandler(addr, command string) error {
	conn, err := net.Dial("tcp", addr)
	if err != nil {
		return err
	}
	defer conn.Close()

	ok, err := checkOnline(conn)
	if err != nil {
		return err
	}
	if !ok {
		return fmt.Errorf("Failed to recieve correct help message")
	}

	ok, err = sendFormattingRequest(conn)
	if err != nil {
		return err
	}
	if !ok {
		return fmt.Errorf("Failed to recieve OK to format message")
	}

	ok, warts, err := sendTrace(conn, command)
	if err != nil {
		return err
	}
	if !ok {
		return fmt.Errorf("Failed to recieve OK to format message")
	}

	if isWarts {
		err = ioutil.WriteFile("y.wart", warts, 0644)
		if err != nil {
			return err
		}
	} else {
		err = ioutil.WriteFile("out.json", warts, 0644)
		if err != nil {
			return err
		}
	}

	return nil
}
