package pathfinder

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"time"

	log "github.com/sirupsen/logrus"
)

/* Generated by LLM */

type Country struct {
	Name   string `json:"name"`
	ISO    string `json:"iso"`
	Threat int    `json:"threat"`
}

type ASN struct {
	ASN     int     `json:"asn"`
	Name    string  `json:"name"`
	Country Country `json:"country"`
	Threat  int     `json:"threat"`
}

type Organization struct {
	Name   string `json:"name"`
	Method string `json:"method"`
}

type Reserved struct {
	Name    string `json:"name"`
	Network string `json:"network"`
}

type Hop struct {
	IP           string       `json:"ip"`
	ProbeTTL     int          `json:"probe_ttl"`
	ASN          ASN          `json:"asn"`
	Country      Country      `json:"country,omitempty"`
	Organization Organization `json:"organization"`
	Reserved     Reserved     `json:"reserved,omitempty"`
	Threat       int          `json:"threat"`
}

type Data struct {
	ID           int       `json:"id"`
	Src          string    `json:"src"`
	Dst          string    `json:"dst"`
	Hops         []Hop     `json:"hops"`
	Finished     bool      `json:"finished"`
	TimeCreated  time.Time `json:"time_created"`
	TimeModified time.Time `json:"time_modified"`
	Errors       []string  `json:"errors"`
}

type Response struct {
	TotalCount int      `json:"totalCount"`
	PageSize   int      `json:"pageSize"`
	Page       int      `json:"page"`
	Data       []Data   `json:"data"`
	Errors     []string `json:"errors"`
}

/* Fin */

type PFObj struct {
	Data   []int
	Errors []string
}

func Query(endpoint, apiKey string, identifier, threshold int) (bool, *Response, error) {

	// now we do a lookup on the code
	endpoint2 := fmt.Sprintf("%s/%d?hops", endpoint, identifier)
	req2, err := http.NewRequest("GET", endpoint2, nil)
	if err != nil {
		return false, nil, err
	}

	req2.Header.Set("Content-Type", "application/json")
	req2.Header.Set("pathfinder-key", apiKey)

	// Send our request
	client := &http.Client{}
	resp2, err := client.Do(req2)
	if err != nil {
		return false, nil, err
	}
	defer resp2.Body.Close()

	//log.Infof("Response code: %d\n", resp2.StatusCode)

	if resp2.StatusCode != http.StatusOK && resp2.StatusCode != http.StatusCreated {
		return false, nil, fmt.Errorf("Http POST failed with status code: %d", resp2.StatusCode)
	}

	body2, err := ioutil.ReadAll(resp2.Body)
	if err != nil {
		return false, nil, err
	}

	// TODO: There may not be a response that is annotated
	// need to detect how to find that,

	var responseData2 *Response
	err = json.Unmarshal(body2, responseData2)
	if err != nil {
		return false, nil, err
	}

	x := responseData2.Data
	for _, d := range x {
		for _, hop := range d.Hops {
			log.Infof("Hop: %s, Threat: %d", hop.IP, hop.Threat)
			if hop.Threat > threshold {
				return true, responseData2, nil
			}
		}
	}

	return false, responseData2, nil
}

func Submit(endpoint, apiKey string, requestData []byte) (bool, int, error) {

	jsonData := "[{\"data\":" + string(requestData) + "}]"

	//log.Infof("our data:\n%s", jsonData)

	req, err := http.NewRequest("POST", endpoint, bytes.NewBuffer([]byte(jsonData)))
	if err != nil {
		return false, 0, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("pathfinder-key", apiKey)

	// Send our request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return false, 0, err
	}
	defer resp.Body.Close()

	//log.Infof("Response code: %d\n", resp.StatusCode)

	// return code is a StatusCreated
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return false, 0, fmt.Errorf("Http POST failed with status code: %d", resp.StatusCode)
	}

	// The response code is an array of uuids for the traces
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, 0, err
	}

	// response: {"data":[118140],"errors":[]}
	responseData := &PFObj{}
	err = json.Unmarshal(body, &responseData)
	if err != nil {
		return false, 0, err
	}

	//log.Infof("the response: %v", responseData)

	d := responseData.Data
	code := 0
	for _, c := range d {
		code = int(c)
	}
	if len(responseData.Errors) > 0 {
		return false, 0, fmt.Errorf("pathfinder returned error: %v", responseData.Errors)
	}

	return true, code, nil
}

func SendRequest(endpoint, apiKey string, threshold int, requestData []byte) (bool, error) {

	/*
		requestData, err := ioutil.ReadFile(inFile)
		if err != nil {
			return false, err
		}
	*/

	// add expectation of how pathfinder wants json data
	jsonData := "[{\"data\":" + string(requestData[1:]) + "}]"

	//log.Infof("our data:\n%s", jsonData)

	req, err := http.NewRequest("POST", endpoint, bytes.NewBuffer([]byte(jsonData)))
	if err != nil {
		return false, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("pathfinder-key", apiKey)

	// Send our request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return false, err
	}
	defer resp.Body.Close()

	//log.Infof("Response code: %d\n", resp.StatusCode)

	// return code is a StatusCreated
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return false, fmt.Errorf("Http POST failed with status code: %d", resp.StatusCode)
	}

	// The response code is an array of uuids for the traces
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err
	}

	// response: {"data":[118140],"errors":[]}
	responseData := &PFObj{}
	err = json.Unmarshal(body, &responseData)
	if err != nil {
		return false, err
	}

	//log.Infof("the response: %v", responseData)

	d := responseData.Data
	code := 0
	for _, c := range d {
		code = int(c)
	}
	if len(responseData.Errors) > 0 {
		return false, fmt.Errorf("pathfinder returned error: %v", responseData.Errors)
	}

	// Now we've gotten a response id, look it up

	// now we do a lookup on the code
	endpoint2 := fmt.Sprintf("%s/%d?hops", endpoint, code)
	req2, err := http.NewRequest("GET", endpoint2, nil)
	if err != nil {
		return false, err
	}

	req2.Header.Set("Content-Type", "application/json")
	req2.Header.Set("pathfinder-key", apiKey)

	// Send our request
	client = &http.Client{}
	resp2, err := client.Do(req2)
	if err != nil {
		return false, err
	}
	defer resp2.Body.Close()

	//log.Infof("Response code: %d\n", resp2.StatusCode)

	if resp2.StatusCode != http.StatusOK && resp2.StatusCode != http.StatusCreated {
		return false, fmt.Errorf("Http POST failed with status code: %d", resp2.StatusCode)
	}

	body2, err := ioutil.ReadAll(resp2.Body)
	if err != nil {
		return false, err
	}

	// TODO: There may not be a response that is annotated
	// need to detect how to find that,

	var responseData2 Response
	err = json.Unmarshal(body2, &responseData2)
	if err != nil {
		return false, err
	}

	x := responseData2.Data
	for _, d := range x {
		for _, hop := range d.Hops {
			log.Infof("Hop: %s, Threat: %d", hop.IP, hop.Threat)
			if hop.Threat > threshold {
				return true, nil
			}
		}
	}

	return false, nil
}
